---
title: "IK WHAT IM DOING BITCH SAY WAA"
author: "Irina Lerner"
date: "27/06/24"
output:
  html_document:
    toc: yes
    toc_float: yes
    theme: paper
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("functions.R")
```

```{r data, include=FALSE}
# customs theme
custom_theme <- theme_minimal() +
                theme(text = element_text(size = 12),
                      plot.title = element_blank(),
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank())

# data loading 100m
shp100 <- st_read("../data/100m/final100.shp")
data100 <- edit_shp(shp100)
alldata100 <- data100
ABdata100 <- alldata100[!is.na(alldata100$AB),]
CRdata100 <- alldata100[!is.na(alldata100$CR),]
POPdata100 <- alldata100[!is.na(alldata100$pop),]

# data loading 100m
shp <- st_read("../data/1km/final1km.shp")
data <- edit_shp(shp)
alldata <- data
CRdata <- alldata[!is.na(alldata$CR),]
POPdata <- CRdata[!is.na(CRdata$pop),]
ABdata <- POPdata[!is.na(POPdata$AB),]
```

# Scale 

```{r, echo=FALSE}
coords <- cbind(alldata100$centx, alldata100$centy)
xy <- st_centroid(alldata100)

s.dist1  <-  dnearneigh(xy, 0, 100)  
s.dist2  <-  dnearneigh(xy, 101, 200)
s.dist3  <-  dnearneigh(xy, 201, 300)
s.dist4  <-  dnearneigh(xy, 301, 400)
s.dist5  <-  dnearneigh(xy, 401, 500)

lw1 <- nb2listw(s.dist1, style="W", zero.policy=T)
lw2 <- nb2listw(s.dist2, style="W", zero.policy=T) 
lw3 <- nb2listw(s.dist3, style="W", zero.policy=T) 
lw4 <- nb2listw(s.dist4, style="W", zero.policy=T) 
lw5 <- nb2listw(s.dist5, style="W", zero.policy=T) 

scale <- alldata100
scale$SVI1 <- calculate_surrounding(s.dist1, scale, "B")
scale$SVI2 <- calculate_surrounding(s.dist2, scale, "B")
scale$SVI3 <- calculate_surrounding(s.dist3, scale, "B")
scale$SVI4 <- calculate_surrounding(s.dist4, scale, "B")
scale$SVI5 <- calculate_surrounding(s.dist5, scale, "B")

scale$SGVI1 <- calculate_surrounding(s.dist1, scale, "C")
scale$SGVI2 <- calculate_surrounding(s.dist2, scale, "C")
scale$SGVI3 <- calculate_surrounding(s.dist3, scale, "C")
scale$SGVI4 <- calculate_surrounding(s.dist4, scale, "C")
scale$SGVI5 <- calculate_surrounding(s.dist5, scale, "C")

scale$SUVI1 <- calculate_surrounding(s.dist1, scale, "A")
scale$SUVI2 <- calculate_surrounding(s.dist2, scale, "A")
scale$SUVI3 <- calculate_surrounding(s.dist3, scale, "A")
scale$SUVI4 <- calculate_surrounding(s.dist4, scale, "A")
scale$SUVI5 <- calculate_surrounding(s.dist5, scale, "A")
```

```{r, include=FALSE}
test_data <- scale[scale$SGVI < 0.7, ]
test_data <- test_data[test_data$SUVI < 0.7, ]

test_AB <- scale[!is.na(scale$AB),]
test_CR <- test_AB[!is.na(test_AB$CR),]

# Base predictors
svi_vars <- c("SVI", "SVI1", "SVI2", "SVI3", "SVI4", "SVI5")
sgvi_vars <- c("SGVI", "SGVI1", "SGVI2", "SGVI3", "SGVI4", "SGVI5")

# Create an empty list to store the models
pred <- c("1")  # Start with intercept-only model

# Function to generate incremental additive models
generate_models <- function(base_vars) {
  models <- c()
  for (i in 1:length(base_vars)) {
    models <- c(models, paste(base_vars[1:i], collapse = " + "))
  }
  return(models)
}

# Generate models for SVI and SGVI separately
svi_models <- generate_models(svi_vars)
sgvi_models <- generate_models(sgvi_vars)

# Combine the models incrementally
combined_models <- c(pred)
for (i in 1:length(svi_models)) {
  for (j in 1:length(sgvi_models)) {
    combined_models <- c(combined_models, paste(svi_models[i], sgvi_models[j], sep = " + "))
  }
}

# Remove duplicates and keep unique combinations
combined_models <- unique(combined_models)

# Print the list of models
print(combined_models)

pred <- c(combined_models, "EVI_mean")
```


```{r, include=FALSE}
CR <- linear_models(test_data, "CR", pred)
AIC_tab_gam(CR)
```

```{r, include=FALSE}
AB <- linear_models(test_AB, "AB", pred)
AIC_tab_gam(AB)
```

```{r, include=FALSE}
POP <- linear_models(test_data, "pop", pred)
AIC_tab_gam(AB)
```

```{r, echo=FALSE}
# Base predictors
svi_vars <- c("SVI", "SVI1", "SVI2")
sgvi_vars <- c("SGVI", "SGVI1", "SGVI2")

# Generate all combinations of the base predictors
combos <- expand.grid(svi_vars, sgvi_vars)

# Create the list of additive and interaction terms for GAM with smooth terms
pred <- c(
  "1",  # Intercept-only model
  paste0("s(", svi_vars, ")"),
  paste0("s(", sgvi_vars, ")"),
  apply(combos, 1, function(x) paste0("s(", x[1], ") + s(", x[2], ")")),
  apply(combos, 1, function(x) paste0("s(", x[1], ", ", x[2], ")"))
)

# Print the list
print(pred)

pred <- c(pred, "s(EVI_mean)")

CR <- gam_models(scale, "CR", pred)
AIC_tab_gam(CR)
```

```{r, echo=FALSE}
AB <- spatial_models(ABdata, "ABn", pred)
AIC_eff_tab(AB, "AB")
```


# Results

## Service supply in $1km^2$

```{r, include=FALSE}
inter <- expand.grid(SVI = seq(0, 1, length.out = 50),
                       SGVI = seq(0, 1, length.out = 50))
inter <- inter[inter$SVI + inter$SGVI <= 1, ]
inter$SUVI <- 1 - inter$SVI - inter$SGVI
inter$centx <- mean(alldata$centx)
inter$centy <- mean(alldata$centy)

fixurban <- expand.grid(SVI = seq(0, 0.9, length.out = 1000))
fixurban$SUVI <- 0.1
fixurban$SGVI <- 1 - fixurban$SVI - fixurban$SUVI
fixurban$centx <- mean(alldata$centx)
fixurban$centy <- mean(alldata$centy)


fixsparing <- expand.grid(SVI = seq(0, 0.9, length.out = 1000))
fixsparing$SGVI <- 0.1
fixsparing$SUVI <- 1 - fixsparing$SVI - fixsparing$SGVI
fixsparing$centx <- mean(alldata$centx)
fixsparing$centy <- mean(alldata$centy)

fixsharing <- expand.grid(SGVI = seq(0, 0.9, length.out = 1000))
fixsharing$SVI <- 0.1
fixsharing$SUVI <- 1 - fixsharing$SVI - fixsharing$SGVI
fixsharing$centx <- mean(alldata$centx)
fixsharing$centy <- mean(alldata$centy)
```

### RF

```{r}
data_rf <- data.frame(CR = ABdata$CR,
                      AB = ABdata$AB,
                      POP = ABdata$pop,
                      prop_veg = ABdata$prop_veg,
                      SGVI = ABdata$SGVI,
                      SVI = ABdata$SVI,
                      SUVI = ABdata$SUVI,
                      centx = scale(ABdata$centx),
                      centy = scale(ABdata$centy))
```

```{r}
# Fit Random Forest model
CR_rf <- randomForest(CR ~ SUVI + SGVI + SVI, data = data_rf, importance = TRUE)
# Plot variable importance
varImpPlot(CR_rf)
```

```{r}
# Fit Random Forest model
AB_rf <- randomForest(AB ~ SUVI + SGVI + SVI, data = data_rf, importance = TRUE)
# Plot variable importance
varImpPlot(AB_rf)
```

```{r}
# Fit Random Forest model
POP_rf <- randomForest(POP ~ SUVI + SGVI + SVI, data = data_rf, importance = TRUE)
# Plot variable importance
varImpPlot(POP_rf)
```

```{r}
# Predict values using the fitted model
fixurban$CRpredicted_rf <- predict(CR_rf, newdata = fixurban, type = "response")
fixurban$ABpredicted_rf <- predict(AB_rf, newdata = fixurban, type = "response")
fixurban$POPpredicted_rf <- predict(POP_rf, newdata = fixurban, type = "response")

fixsharing$CRpredicted_rf <- predict(CR_rf, newdata = fixsharing, type = "response")
fixsharing$ABpredicted_rf <- predict(AB_rf, newdata = fixsharing, type = "response")
fixsharing$POPpredicted_rf <- predict(POP_rf, newdata = fixsharing, type = "response")

fixsparing$CRpredicted_rf <- predict(CR_rf, newdata = fixsparing, type = "response")
fixsparing$ABpredicted_rf <- predict(AB_rf, newdata = fixsparing, type = "response")
fixsparing$POPpredicted_rf <- predict(POP_rf, newdata = fixsparing, type = "response")

FU <- ggplot(fixurban) +
      geom_smooth(aes(x = SVI, y = normalize(CRpredicted_rf)), method = "loess", formula = y ~ x, color = "turquoise") +
      geom_smooth(aes(x = SVI, y = normalize(ABpredicted_rf)), method = "loess", formula = y ~ x, color = "purple") +
      geom_smooth(aes(x = SVI, y = normalize(POPpredicted_rf)), method = "loess", formula = y ~ x, color = "orange") +
      labs(title = "(A) Replace sparing green with sharing",
           x = "SVI",
           y = "",
           color = "") +
      theme_bw() +
      theme(
        plot.title = element_text(size = 10),
        axis.title = element_text(size = 8),
        axis.text = element_text(size = 8),
        legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())


FS <- ggplot(fixsharing) +
      geom_smooth(aes(x = SUVI, y = normalize(CRpredicted_rf)), method = "loess", formula = y ~ x, color = "turquoise") +
      geom_smooth(aes(x = SUVI, y = normalize(ABpredicted_rf)), method = "loess", formula = y ~ x, color = "purple") +
      geom_smooth(aes(x = SUVI, y = normalize(POPpredicted_rf)), method = "loess", formula = y ~ x, color = "orange") +
      labs(title = "(B) Replace sparing urban with sparing green",
           x = "SUVI",
           y = "",
           color = "") +
      theme_bw() +
      theme(
        plot.title = element_text(size = 10),
        axis.title = element_text(size = 8),
        axis.text = element_text(size = 8),
        legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

FGr <- ggplot(fixsparing) +
      geom_smooth(aes(x = SUVI, y = normalize(CRpredicted_rf)), method = "loess", formula = y ~ x, color = "turquoise") +
      geom_smooth(aes(x = SUVI, y = normalize(ABpredicted_rf)), method = "loess", formula = y ~ x, color = "purple") +
      geom_smooth(aes(x = SUVI, y = normalize(POPpredicted_rf)), method = "loess", formula = y ~ x, color = "orange") +
      labs(title = "(C) Replace sparing urban with sharing",
           x = "SUVI",
           y = "",
           color = "") +
      theme_bw() +
      theme(
        plot.title = element_text(size = 10),
        axis.title = element_text(size = 8),
        axis.text = element_text(size = 8),
        legend.position = "none",
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

legend2 <- cowplot::get_plot_component(FG, 'guide-box-right', return_all = TRUE)
  
legend_grob2 <- cowplot::ggdraw(legend2)

grid.arrange(
  FU, FS, FGr, legend_grob2,
  ncol = 4,
  nrow = 1,
  top = ""
)
```

### multivariate regression tree

```{r}
train_data <- as.data.frame(scale)#[train_indices, ]

train_data <- train_data %>%
  mutate(CRn = scale(train_data$CR),
         ABn = scale(train_data$AB),
         popn = scale(train_data$pop))

# Define the training datasets
X_train <- train_data %>% select(SVI, SVI1, SVI2, SVI3, SVI4, SGVI, SGVI1, SGVI2, SGVI3, SGVI4)
#X_train <- train_data %>% select(SVI, SGVI, SUVI)
Y_train <- train_data %>% select(CRn, ABn, popn)

# Combine the response variables into a matrix
response <- cbind(SBmean = Y_train$CRn,  Y_train$ABn, Y_train$popn)

mvpart_model <- mvpart(response ~ ., data = X_train,
                    xv = "none", # select smallest tree within 1 se
                    #xval = nrow(response), # number of cross-validations
                    #xvmult = 100, # number of multiple cross-validations
                    size = 8,
                    which = 4,
                    legend = FALSE, margin = 0.01, cp = 0, prn = F)
```

```{r}
mvpart_model <- mvpart(response ~ ., data = X_train,
                    xv = "none", # select smallest tree within 1 se
                    #xval = nrow(response), # number of cross-validations
                    #xvmult = 100, # number of multiple cross-validations
                    size = 8,
                    which = 4,
                    legend = FALSE, margin = 0.01, cp = 0, prn = F)
```

```{r}
# Plot the cross-validated error to find the optimal tree size
plotcp(mvpart_model)
```

```{r}
# Add the leaf nodes to your data
alldata$LeafNode <- as.factor(as.numeric(predict(mvpart_model, newdata = alldata, type = "where")))
# Plot the map, coloring by the leaf node
ggplot(data = alldata) +
  geom_sf(aes(fill = LeafNode), color = NA) +
  scale_fill_viridis_d() +  # Use a discrete color scale
  theme_minimal() +
  custom_theme +
    theme(legend.position = "none",
          plot.title = element_text(size = 10),
          axis.text = element_blank())
```

Now we make a boxplot for each node

```{r, echo = F}
# Colors for each variable
colors <- c("turquoise", "purple", "orange")

# Unique LeafNodes
leaf_nodes <- unique(alldata$LeafNode)

# Set up plotting area to display multiple plots
par(mfrow = c(1, 6), mar = c(4, 4, 2, 1))

# Create a boxplot for each LeafNode
for (node in sort(leaf_nodes)) {
  subset_data <- alldata[alldata$LeafNode == node, ]
  
  boxplot(subset_data$CRn, subset_data$ABn, subset_data$popn,
              names = c("CR", "AB", "pop"),
              col = colors,
            ylim = c(0, 1))
}


# Loop through each leaf node and create a plot
plots <- list()
i = 1
for (node in sort(leaf_nodes)) {
 p <- ggplot(data = alldata) +
    geom_sf(aes(fill = ifelse(LeafNode == node, as.character(node), "Other")), color = NA) +
    scale_fill_manual(values = c(setNames(viridis::viridis(length(leaf_nodes)), leaf_nodes), "Other" = "gray")) +  # Custom colors
    custom_theme +
    theme(legend.position = "none",
          plot.title = element_text(size = 10),
          axis.text = element_blank())
  
 plot(p)
  plots[[i]] <- p
}

# Combine all map plots into one layout
combined_plot <- marrangeGrob(grobs = plots, ncol = 3, nrow = 2)

# Display the combined map plot
grid.newpage()
grid.draw(combined_plot)

```
