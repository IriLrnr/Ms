---
title: "Effects of urban green infrastructure on supply provision of ecosystem service: Temperature reduction"
author: "Irina Lerner"
date: "30/01/24"
output:
  html_document:
    toc: yes
    toc_float: yes
    theme: paper
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("functions2.R")

# customs
custom_theme <- theme_minimal() +
                theme(text = element_text(size = 12),
                      plot.title = element_blank(),
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank())
```


# Data

We begin with the smallest data sample, 100m2 grid.

```{r data, include=FALSE}
# Load data
cdata <- edit_shp(st_read("../data/100m/final_data_100.shp"))
# Temperature edit
cdata$LTM <- log(cdata$T_mean)
```

The data set is a 100m² grid over the city of São Paulo. Main variables are

*T_mean* - the mean temperature of the cell

*SBmean* - the mean scenic beauty of the cell

*BH* - Building mean height

*BV* - Building mean volume

*VH* - Vegetation mean height

*VH* - Vegetation mean volume

*EVI_mean* - Mean EVI for the cell. EVI map is a 30m² grid, there is ~ 9 EVI cells in a 100m² grid

*SUVI* - proportion of areas inside a cell with EVI < 0.15 (urban)

*SVI* - proportion of areas inside a cell with 0.15 < EVI < 0.56 (mixed)

*SGVI* - proportion of areas inside a cell with EVI > 0.56 (green)


# Vegetation

Show São paulo in terms of Sharing and Sparing in the 100m2 grid

```{r}
# Create neighbors list based on a distance threshold
plot_bi_map(cdata, "SGVI", "SVI")
```

We can see that, at this scale, data is either High SVI, High SGVI or low on both, meaning high SUVI. 

Lets then cluster based on the mean EVI

```{r}
nb <- poly2nb(cdata)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)

MCi_EVI <- localmoran_perm(cdata$EVI_mean, lw, nsim = 999)
cdata$pEVI  <- (as.data.frame(MCi_EVI))$`Pr(folded) Sim`

cdata$Ii_EVI <- hotspot(MCi_EVI, Prname="Pr(folded) Sim", cutoff = 0.05, p.adjust = "fdr")
cdata$Ii_EVI <- factor(cdata$Ii_EVI, levels=c("Low-Low", "High-Low", "Low-High", "High-High", ">0.05 corrected"))
cdata$Ii_EVI[is.na(cdata$Ii_EVI)] <- ">0.05 corrected"

ggplot(data = cdata) +
  geom_sf(aes(fill = Ii_EVI), color = NA) +
  scale_fill_viridis_d() +
  custom_theme
```


Alternativelly, we can cathegorize by EVI in the 100m scale

```{r}
cdata$group <- as.character(cdata$Ii_EVI)
cdata$group[cdata$Ii_EVI %in% ">0.05 corrected"] <- "Mixed"
cdata$group[cdata$Ii_EVI %in% c("High-High")] <- "Green"
cdata$group[cdata$Ii_EVI %in% c("Low-Low")] <- "Urban"
cdata$group[cdata$Ii_EVI %in% c("Low-High")] <- "Green"
cdata$group[cdata$Ii_EVI %in% c("High-Low")] <- "Urban"
cdata$group <- factor(cdata$group)

ggplot(cdata) +
  geom_sf(aes(fill = group), color = NA, size = 0.1) +  # Remove borders with colour = NA
  custom_theme
```
```{r}
# Create neighbors list based on a distance threshold
plot_bi_map(cdata, "Cat", "group")
```

# Services

Finding how much in average each service is affected by category and surrounding

```{r}
# Define a vector of colors for each group
group_colors <- c("darkgreen", "lightgreen", "greenyellow", "yellow", "gold", "orange", "red", "red3", "red4")



cdata$finalgroups <- paste(cdata$Cat, cdata$group)
med <- sort(tapply(cdata$T_mean, cdata$finalgroups, mean))
cdata$finalgroups <- factor(cdata$finalgroups, levels = names(med))
boxplot(T_mean ~ finalgroups, data = cdata,
    col = group_colors)
```
```{r}
sbdata <- cdata[!is.na(cdata$SBmean),]

sbdata$finalgroups <- paste(sbdata$Cat, sbdata$group)


med <- sort(tapply(sbdata$SBmean/sbdata$SBcount, sbdata$finalgroups, mean))
sbdata$finalgroups <- factor(sbdata$finalgroups, levels = names(med))
boxplot(SBmean/SBcount ~ finalgroups, data = sbdata,
    col = group_colors)
```

```{r}
pop <- sort(tapply(cdata$pop_d, cdata$finalgroups, mean))
cdata$finalgroups <- factor(cdata$finalgroups, levels = names(pop))
boxplot(pop_d ~ finalgroups, data = cdata,
    col = group_colors)
```

```{r}
summary(cdata$finalgroups)
```

We found a good EVI influence of ~300 m. let's consider this lag. Maybe later add some for the final model.

```{r}
coords <- st_centroid(cdata)
nb <- dnearneigh(coords, 0, 300)  # Neighbors within 0 to threshold distance
lw <- nb2listw(nb, style="W", zero.policy=TRUE)

# Calculate spatial lags for predictors
cdata$EVI_lag <- lag.listw(lw, cdata$EVI_mean)
cdata$SVI_lag <- lag.listw(lw, cdata$SVI)
cdata$SGVI_lag <- lag.listw(lw, cdata$SGVI)
cdata$SUVI_lag <- lag.listw(lw, cdata$SUVI)
```

# Temperature random forest

what is left is to understand random forests and how to showcase its results. And explore lags for discussion.


```{r}
#library(parallel)
#library(doParallel)

data_rf <- data.frame(t = cdata$T_mean,
                      EVI = cdata$EVI_mean,
                      SGVI = cdata$SGVI,
                      SVI = cdata$SVI,
                      SUVI = cdata$SUVI,
                      EVI_lag = cdata$EVI_lag,
                      SVI_lag = cdata$SVI_lag,
                      SGVI_lag = cdata$SGVI_lag,
                      SUVI_lag = cdata$SUVI_lag,
                      coord_x = cdata$centx,
                      coord_y = cdata$centy)

# Set up parallel processing
#cl <- makeCluster(detectCores() - 1)  # Use one less than the total number of cores
#registerDoParallel(cl)

# Fit Random Forest model
rf_model <- randomForest(t ~ ., data = data_rf, importance = TRUE) #, parallel = TRUE)

# Summarize the model
print(rf_model)
importance(rf_model)

# Partial Dependence Plot for SVI
pdp_svi <- partial(rf_model, pred.var = "SVI", plot = TRUE)
pdp_sgvi <- partial(rf_model, pred.var = "SGVI", plot = TRUE)
pdp_suvi <- partial(rf_model, pred.var = "SUVI", plot = TRUE)
pdp_evi <- partial(rf_model, pred.var = "EVI", plot = TRUE)

# Partial Dependence Plot for SVI_lag
pdp_svi_lag <- partial(rf_model, pred.var = "SVI_lag", plot = TRUE)
pdp_sgvi_lag <- partial(rf_model, pred.var = "SGVI_lag", plot = TRUE)
pdp_suvi_lag <- partial(rf_model, pred.var = "SUVI_lag", plot = TRUE)
pdp_evi_lag <- partial(rf_model, pred.var = "EVI_lag", plot = TRUE)

# Display plots
plot(pdp_evi)
plot(pdp_sgvi)
plot(pdp_suvi)
plot(pdp_svi)
plot(pdp_evi_lag)
plot(pdp_svi_lag)
plot(pdp_sgvi_lag)
plot(pdp_suvi_lag)

# Stop the cluster
#stopCluster(cl)
```

# Scenic beauty random forest

```{r}
sbdata <- cdata[!is.na(cdata$SBmean),]

data_rf2 <- data.frame(sb = sbdata$SBmean,
                      EVI = sbdata$EVI_mean,
                      SGVI = sbdata$SGVI,
                      SVI = sbdata$SVI,
                      SUVI = sbdata$SUVI,
                      EVI_lag = sbdata$EVI_lag,
                      SVI_lag = sbdata$SVI_lag,
                      SGVI_lag = sbdata$SGVI_lag,
                      SUVI_lag = sbdata$SUVI_lag,
                      coord_x = sbdata$centx,
                      coord_y = sbdata$centy)

# Fit Random Forest model
rf_model2 <- randomForest(sb ~ ., data = data_rf2, importance = TRUE)

# Summarize the model
print(rf_model2)
importance(rf_model2)

# Partial Dependence Plot for SVI
pdp_svi2 <- partial(rf_model2, pred.var = "SVI", plot = TRUE)
pdp_sgvi2 <- partial(rf_model2, pred.var = "SGVI", plot = TRUE)
pdp_suvi2 <- partial(rf_model2, pred.var = "SUVI", plot = TRUE)
pdp_evi2 <- partial(rf_model2, pred.var = "EVI", plot = TRUE)

# Partial Dependence Plot for SVI_lag
pdp_svi_lag2 <- partial(rf_model2, pred.var = "SVI_lag", plot = TRUE)
pdp_sgvi_lag2 <- partial(rf_model2, pred.var = "SGVI_lag", plot = TRUE)
pdp_suvi_lag2 <- partial(rf_model2, pred.var = "SUVI_lag", plot = TRUE)
pdp_evi_lag2 <- partial(rf_model2, pred.var = "EVI_lag", plot = TRUE)

# Display plots
plot(pdp_evi2)
plot(pdp_sgvi2)
plot(pdp_suvi2)
plot(pdp_svi2)
plot(pdp_evi_lag2)
plot(pdp_svi_lag2)
plot(pdp_sgvi_lag2)
plot(pdp_suvi_lag2)
```


