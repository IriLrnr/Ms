---
title: "Effects of urban green infrastructure on supply provision of ecosystem service: Temperature reduction"
author: "Irina Lerner"
date: "30/01/24"
output:
  html_document:
    toc: yes
    toc_float: yes
    theme: paper
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
source("functions2.R")

# customs
custom_theme <- theme_minimal() +
                theme(text = element_text(size = 12),
                      plot.title = element_blank(),
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank())
```


# Data

We begin with the smallest data sample, 100m2 grid.

```{r data, include=FALSE}
# Load data
cdata <- edit_shp(st_read("../Cities/SP/100m/tryU.shp"))
# Temperature edit
cdata$LTM <- log(cdata$T_mean)

#sbdata <- cdata[!is.na(cdata$SBmean),]
```

The data set is a 100m² grid over the city of São Paulo. Main variables are

*T_mean* - the mean temperature of the cell

*RM* - Micro climatic region

*prop_veg* - proportion of vegetation

*prop_water* - proportion of water cover

*BH* - Building mean height

*BV* - Building mean volume

*VH* - Vegetation mean height

*VH* - Vegetation mean volume

*EVI_mean* - Mean EVI for the cell. EVI map is a 30m² grid, there is ~ 9 EVI cells in a 100m² grid

*SUVI* - proportion of areas inside a cell with EVI < 0.15 (urban)

*SVI* - proportion of areas inside a cell with 0.15 < EVI < 0.56 (mixed)

*SGVI* - proportion of areas inside a cell with EVI > 0.56 (green)


# Vegetation

Show São paulo in terms of Sharing and Sparing in the 100m2 grid

```{r}
# Create neighbors list based on a distance threshold
plot_bi_map(cdata, "SGVI", "SVI")
```

We can see that, at this scale, data is either High SVI, High SGVI or low on both, meaning high SUVI. 

Lets then cluster based on the mean EVI

```{r}
nb <- poly2nb(cdata)
lw <- nb2listw(nb, style="W", zero.policy=TRUE)

MCi_EVI <- localmoran_perm(cdata$EVI_mean, lw, nsim = 999)
cdata$pEVI  <- (as.data.frame(MCi_EVI))$`Pr(folded) Sim`

cdata$Ii_EVI <- hotspot(MCi_EVI, Prname="Pr(folded) Sim", cutoff = 0.05, p.adjust = "fdr")
cdata$Ii_EVI <- factor(cdata$Ii_EVI, levels=c("Low-Low", "High-Low", "Low-High", "High-High", ">0.05 corrected"))
cdata$Ii_EVI[is.na(cdata$Ii_EVI)] <- ">0.05 corrected"

ggplot(data = cdata) +
  geom_sf(aes(fill = Ii_EVI), color = NA) +
  scale_fill_viridis_d() +
  custom_theme
```


Alternativelly, we can cathegorize by EVI in the 100m scale

```{r}
cdata$group <- as.character(cdata$Ii_EVI)
cdata$group[cdata$Ii_EVI %in% ">0.05 corrected"] <- "Mixed"
cdata$group[cdata$Ii_EVI %in% c("High-High")] <- "Green"
cdata$group[cdata$Ii_EVI %in% c("Low-Low")] <- "Urban"
cdata$group[cdata$Ii_EVI %in% c("Low-High")] <- "Green"
cdata$group[cdata$Ii_EVI %in% c("High-Low")] <- "Urban"
cdata$group <- factor(cdata$group)

ggplot(cdata) +
  geom_sf(aes(fill = group), color = NA, size = 0.1) +  # Remove borders with colour = NA
  custom_theme
```
```{r}
# Create neighbors list based on a distance threshold
plot_bi_map(cdata, "Cat", "group")
```

# Services

Finding how much in average each service is affected by category and surrounding

```{r}
# Define a vector of colors for each group
group_colors <- c("darkgreen", "lightgreen", "greenyellow", "yellow", "gold", "orange", "red", "red3", "red4")



cdata$finalgroups <- paste(cdata$Cat, cdata$group)
med <- sort(tapply(cdata$T_mean, cdata$finalgroups, mean))
cdata$finalgroups <- factor(cdata$finalgroups, levels = names(med))
boxplot(T_mean ~ finalgroups, data = cdata,
    col = group_colors)
```
```{r}
sbdata <- cdata[!is.na(cdata$SBmean),]

sbdata$finalgroups <- paste(sbdata$Cat, sbdata$group)


med <- sort(tapply(sbdata$SBmean/sbdata$SBcount, sbdata$finalgroups, mean))
sbdata$finalgroups <- factor(sbdata$finalgroups, levels = names(med))
boxplot(SBmean/SBcount ~ finalgroups, data = sbdata,
    col = group_colors)
```

```{r}

pop <- sort(tapply(cdata$pop_d, cdata$finalgroups, mean))
cdata$finalgroups <- factor(cdata$finalgroups, levels = names(pop))
boxplot(pop_d ~ finalgroups, data = cdata,
    col = group_colors)
```

```{r}
summary(cdata$finalgroups)
```

We found a good EVI influence of ~300 m. let's consider this lag. Maybe later add some for the final model.

```{r}
coords <- st_centroid(cdata)
nb <- dnearneigh(coords, 0, 300)  # Neighbors within 0 to threshold distance
lw <- nb2listw(nb, style="W", zero.policy=TRUE)

# Calculate spatial lags for predictors
cdata$EVI_lag <- lag.listw(lw, cdata$EVI_mean)
cdata$SVI_lag <- lag.listw(lw, cdata$SVI)
cdata$SGVI_lag <- lag.listw(lw, cdata$SGVI)
cdata$SUVI_lag <- lag.listw(lw, cdata$SUVI)
```
# Temperature random forest

what is left is to understand random forests and how to showcase its results. And explore lags for discussion.

```{r}
data_rf <- data.frame(t = cdata$T_mean,
                      EVI = cdata$EVI_mean,
                      SGVI = cdata$SGVI,
                      SVI = cdata$SVI,
                      SUVI = cdata$SUVI,
                      EVI_lag = cdata$EVI_lag,
                      SVI_lag = cdata$SVI_lag,
                      SGVI_lag = cdata$SGVI_lag,
                      SUVI_lag = cdata$SUVI_lag,
                      coord_x = cdata$centx,
                      coord_y = cdata$centy)


# Fit Random Forest model
rf_model <- randomForest(t ~ ., data = data_rf, importance = TRUE)

# Summarize the model
print(rf_model)
importance(rf_model)

# Partial Dependence Plot for SVI
pdp_svi <- partial(rf_model, pred.var = "SVI", plot = TRUE)
pdp_sgvi <- partial(rf_model, pred.var = "SGVI", plot = TRUE)
pdp_suvi <- partial(rf_model, pred.var = "SUVI", plot = TRUE)
pdp_evi <- partial(rf_model, pred.var = "EVI", plot = TRUE)

# Partial Dependence Plot for SVI_lag
pdp_svi_lag <- partial(rf_model, pred.var = "SVI_lag", plot = TRUE)
pdp_sgvi_lag <- partial(rf_model, pred.var = "SGVI_lag", plot = TRUE)
pdp_suvi_lag <- partial(rf_model, pred.var = "SUVI_lag", plot = TRUE)
pdp_evi_lag <- partial(rf_model, pred.var = "EVI_lag", plot = TRUE)


# Display plots
plot(pdp_evi)
plot(pdp_sgvi)
plot(pdp_suvi)
plot(pdp_svi)
plot(pdp_evi_lag)
plot(pdp_svi_lag)
plot(pdp_sgvi_lag)
plot(pdp_suvi_lag)

# Partial Dependence Plot for interaction between SVI and SGVI
pdp_interaction <- partial(rf_model, pred.var = c("SVI", "SGVI"), plot = TRUE, chull = TRUE)
plot(pdp_interaction)

# Partial Dependence Plot for interaction between SVI and SUVI_lag
pdp_interaction2 <- partial(rf_model, pred.var = c("SVI", "SUVI_lag"), plot = TRUE, chull = TRUE)
plot(pdp_interaction2)
library(ICEbox)

# ICE plot for SVI
ice_obj <- ice(rf_model, X = data_rf, y = data_rf$t, predictor = "SVI", ice.type = "both")
plot(ice_obj, x_quantile = TRUE)

# not run 
library(parallel)
library(doParallel)

# Set up parallel processing
cl <- makeCluster(detectCores() - 1)  # Use one less than the total number of cores
registerDoParallel(cl)

# PDP for interaction between SVI and SGVI with parallel processing
pdp_interaction <- partial(rf_model, pred.var = c("SVI", "SGVI"), plot = TRUE, chull = TRUE, parallel = TRUE)
plot(pdp_interaction)

# Stop the cluster
stopCluster(cl)
```

```{r}
# Create spatial weights matrices with optimal distances
nb_SVI <- dnearneigh(st_coordinates(cdata), 0, optimal_distance_SVI)
listw_SVI <- nb2listw(nb_SVI, style = "W")
cdata$SVI_lag <- lag.listw(listw_SVI, cdata$SVI)

nb_SGVI <- dnearneigh(st_coordinates(cdata), 0, optimal_distance_SGVI)
listw_SGVI <- nb2listw(nb_SGVI, style = "W")
cdata$SGVI_lag <- lag.listw(listw_SGVI, cdata$SGVI)

nb_SUVI <- dnearneigh(st_coordinates(cdata), 0, optimal_distance_SUVI)
listw_SUVI <- nb2listw(nb_SUVI, style = "W")
cdata$SUVI_lag <- lag.listw(listw_SUVI, cdata$SUVI)

# Fit the final model with optimal lags
final_model <- lm(temperature ~ SVI + SGVI + SUVI + SVI_lag + SGVI_lag + SUVI_lag, data = cdata)
summary(final_model)

```
